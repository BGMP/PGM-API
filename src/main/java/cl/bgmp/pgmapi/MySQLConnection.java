package cl.bgmp.pgmapi;

import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.logging.Logger;
import org.bukkit.entity.Player;

public class MySQLConnection {
  private Connection connection;
  private String host = Config.MySQL.getHost();
  private String database = Config.MySQL.getDatabase();
  private String username = Config.MySQL.getUsername();
  private String password = Config.MySQL.getPassword();
  private int port = Config.MySQL.getPort();
  private String usersTable = Config.MySQL.getUsersTable();
  private String pgmTable = Config.MySQL.getPGMTable();
  private Logger logger;

  public MySQLConnection(final Logger logger) {
    this.logger = logger;
    this.connect();
    if (!pgmTableExists()) this.touchPGMTable();
    else logger.info("PGM attached to table: " + pgmTable);
  }

  /**
   * Registers a player into the database only if the player does not yet exist
   *
   * @param uuid Player to be registered's uuid
   * @param nick Player to be registered's nick TODO: Test name changes
   */
  public void registerPlayer(String uuid, String nick) {
    if (playerIsRegistered(uuid)) {
      final String pgmNick =
          simpleStringGet(pgmTable, "uuid", uuid, "nick"); // Player's nick record at the PGM table
      final String usersNick =
          simpleStringGet(
              usersTable, "uuid", uuid, "nick"); // Player's nick record at BungeeAuthenticator

      assert pgmNick != null && usersNick != null;
      if (!pgmNick.equals(usersNick)) {
        // Update the nick at the PGM table in case of mismatch (aka: When a player changes their
        // nickname)
        try {
          PreparedStatement statement =
              connection.prepareStatement("UPDATE " + pgmTable + " SET nick = ? WHERE uuid = ?");
          statement.setString(1, usersNick);
          statement.setString(2, uuid);
          statement.executeUpdate();
        } catch (SQLException exception) {
          exception.printStackTrace();
        }
      }
    } else {
      try {
        PreparedStatement insertion =
            connection.prepareStatement(
                "INSERT INTO "
                    + pgmTable
                    + " (uuid, nick, kills, deaths, killed) VALUES (?, ?, ?, ?, ?)");
        insertion.setString(1, uuid);
        insertion.setString(2, nick);
        insertion.setInt(3, 0);
        insertion.setInt(4, 0);
        insertion.setInt(5, 0);
        insertion.executeUpdate();
      } catch (SQLException e) {
        e.printStackTrace();
      }
    }
  }

  /**
   * Checks if the provided uuid exists in the database
   *
   * @param uuid The uuid to be searched for
   * @return Whether or not the uuid is present in the database
   */
  private boolean playerIsRegistered(final String uuid) {
    return rowValueIsPresent(pgmTable, "uuid", uuid);
  }

  /**
   * Retrieves the UUID generated by BungeeAuthenticator
   *
   * @param player The player whom's uuid will be retrieved
   * @return The UUID associated with the provided player
   */
  public String getPlayerUUID(final Player player) {
    return simpleStringGet(usersTable, "nick", player.getName(), "uuid");
  }

  public PGMPlayer getPGMPlayer(String uuid, String nick) {
    try {
      PreparedStatement statement =
          connection.prepareStatement("SELECT * FROM " + pgmTable + " WHERE uuid = ?");
      statement.setString(1, uuid);

      ResultSet results = statement.executeQuery();
      results.next();

      return new PGMPlayer(
          uuid, nick, results.getInt("kills"), results.getInt("deaths"), results.getInt("killed"));
    } catch (SQLException e) {
      e.printStackTrace();
    }
    return null;
  }

  public void deployPGMPlayerStats(PGMPlayer pgmPlayer) {
    try {
      PreparedStatement statement =
          connection.prepareStatement(
              "UPDATE " + pgmTable + " SET kills = ?, deaths = ?, killed = ? WHERE uuid = ?");
      statement.setInt(1, pgmPlayer.getKills());
      statement.setInt(2, pgmPlayer.getDeaths());
      statement.setInt(3, pgmPlayer.getKilled());
      statement.setString(4, pgmPlayer.getUUID());
      statement.executeUpdate();
    } catch (SQLException exception) {
      exception.printStackTrace();
    }
  }

  /**
   * Simple database get operation, generalised through this method to avoid boilerplate
   *
   * @param table The table containing the provided column
   * @param column The column in which the query will be searched for
   * @param query The value to be searched for in the given column
   * @param match The desired column, which contains the value that will be returned, as living in
   *     the same row as query
   * @return The value of column match living in the same row query was found at
   */
  private String simpleStringGet(String table, String column, String query, String match) {
    try {
      PreparedStatement statement =
          connection.prepareStatement("SELECT * FROM " + table + " WHERE " + column + " = ?");
      statement.setString(1, query);

      ResultSet results = statement.executeQuery();
      results.next();

      return results.getString(match);
    } catch (SQLException e) {
      e.printStackTrace();
    }
    return null;
  }

  /**
   * Performs a search within one column of a given table, returning whether or not the value
   * provided could be found at it or not
   *
   * @param table The table in which the search will be performed at
   * @param column The table's column in which the search will take place at
   * @param value The value that will be searched for at the column
   * @return Whether or not the value was found
   */
  private boolean rowValueIsPresent(String table, String column, String value) {
    try {
      PreparedStatement statement =
          connection.prepareStatement("SELECT * FROM " + table + " WHERE " + column + " = ?");
      statement.setString(1, value);

      ResultSet results = statement.executeQuery();
      return results.next();
    } catch (SQLException ignore) {
    }
    return false;
  }

  private void connect() {
    synchronized (PGMAPI.class) {
      try {
        if (connection != null && !connection.isClosed()) return;

        Class.forName("com.mysql.jdbc.Driver");
        final String url =
            "jdbc:mysql://"
                + host
                + ":"
                + port
                + "/"
                + database
                + "?autoReconnect=true&useSSL=false";

        connection = DriverManager.getConnection(url, username, password);
      } catch (ClassNotFoundException | SQLException e) {
        logger.severe("Error establishing MySQL connection. Check your config.yml file.");
        e.printStackTrace();
      }
    }
  }

  /** Gives the PGM table a touch, so it pops up in mysql */
  private void touchPGMTable() {
    try {
      final Statement statement = connection.createStatement();
      statement.executeUpdate(
          "CREATE TABLE "
              + pgmTable
              + "(uuid VARCHAR (36) NOT NULL,"
              + "nick VARCHAR (16) NOT NULL,"
              + "kills INT (11) NOT NULL,"
              + "deaths INT (11) NOT NULL, "
              + "killed INT (11) NOT NULL)"
              + "ENGINE=InnoDB DEFAULT CHARSET=utf8;");

      logger.info("Initialised PGM table: " + pgmTable);
    } catch (SQLException e) {
      logger.severe("Error while initialising PGM's table: " + pgmTable);
      e.printStackTrace();
    }
  }

  /**
   * Verifies if the table specified for PGM exists or not
   *
   * @return Whether or not the table exists
   */
  private boolean pgmTableExists() {
    try {
      final DatabaseMetaData databaseMetaData = connection.getMetaData();
      final ResultSet resultSet = databaseMetaData.getTables(null, null, pgmTable, null);
      return resultSet.next();
    } catch (SQLException e) {
      logger.severe("Exception on database read operation.");
      e.printStackTrace();
    }
    return false;
  }
}
